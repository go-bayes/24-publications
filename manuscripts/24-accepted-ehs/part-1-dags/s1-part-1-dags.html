<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>s1-part-1-dags</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="s1-part-1-dags_files/libs/clipboard/clipboard.min.js"></script>
<script src="s1-part-1-dags_files/libs/quarto-html/quarto.js"></script>
<script src="s1-part-1-dags_files/libs/quarto-html/popper.min.js"></script>
<script src="s1-part-1-dags_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="s1-part-1-dags_files/libs/quarto-html/anchor.min.js"></script>
<link href="s1-part-1-dags_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="s1-part-1-dags_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="s1-part-1-dags_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="s1-part-1-dags_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="s1-part-1-dags_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<hr>
<p>title: ‘Supplementary files for “Methods in Causal Inference Part 1: Causal Diagrams and Confounding”’</p>
<p>author:</p>
<ul>
<li><p>name: Joseph A. Bulbulia</p>
<p>affiliation: Victoria University of Wellington, New Zealand</p>
<p>orcid: 0000-0002-5861-2056</p>
<p>email: joseph.bulbulia@vuw.ac.nz</p>
<p>corresponding: no</p></li>
</ul>
<p>editor_options:</p>
<p>chunk_output_type: console</p>
<p>format:</p>
<p>pdf:</p>
<pre><code>sanitise: true

keep-tex: true

link-citations: true

colorlinks: true

documentclass: article

classoption: [single column]

lof: false

lot: true

toc: true

toc-depth: 2

geometry:

  - top=30mm

  - left=25mm

  - heightrounded

  - headsep=22pt

  - headheight=11pt

  - footskip=33pt

  - ignorehead

  - ignorefoot

template-partials: 

  - /Users/joseph/GIT/templates/quarto/title.tex

header-includes:

  - \input{/Users/joseph/GIT/latex/latex-for-quarto.tex}</code></pre>
<p>date: last-modified</p>
<p>execute:</p>
<p>echo: false</p>
<p>warning: false</p>
<p>include: true</p>
<p>eval: true</p>
<p>fontfamily: libertinus</p>
<p>bibliography: /Users/joseph/GIT/templates/bib/references.bib</p>
<p>csl: /Users/joseph/GIT/templates/csl/camb-a.csl</p>
<hr>
<div style="page-break-after: always;"></div>
<section id="id-app-a" class="level2">
<h2 class="anchored" data-anchor-id="id-app-a">S1. Glossary</h2>
<div id="tbl-experiments" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-experiments-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Glossary
</figcaption>
<div aria-describedby="tbl-experiments-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">

</div>
</figure>
</div>
<div style="page-break-after: always;"></div>
</section>
<section id="id-app-b" class="level2">
<h2 class="anchored" data-anchor-id="id-app-b">S2. Causal Inference in History: The Difficulty in Satisfying the Three Fundamental Assumptions for Causal Inference</h2>
<p>Consider the Protestant Reformation of the 16th century, which initiated religious change throughout much of Europe. Historians have argued that Protestantism caused social, cultural, and economic changes in those societies where it took hold (see: <span class="citation" data-cites="weber1905">@weber1905</span>; <span class="citation" data-cites="weber1993">@weber1993</span>; <span class="citation" data-cites="swanson1967">@swanson1967</span>; <span class="citation" data-cites="swanson1971">@swanson1971</span>; <span class="citation" data-cites="basten2013">@basten2013</span>, and for an overview, see: <span class="citation" data-cites="becker2016">@becker2016</span>).</p>
<p>Suppose we want to estimate the Protestant Reformation’s ‘Average Treatment Effect’. Let <span class="math inline">\(A = a^*\)</span> denote the adoption of Protestantism. We compare this effect with that of remaining Catholic, represented as <span class="math inline">\(A = a\)</span>. We assume that both the concepts of ‘adopting Protestantism’ and ‘economic development’ are well-defined (e.g., GDP +1 century after a country has a Protestant majority contrasted with remaining Catholic). The causal effect for any individual country is <span class="math inline">\(Y_i(a^*) - Y_i(a)\)</span>. Although we cannot identify this effect, if the basic assumptions of causal inference are met, we can estimate the average or marginal effect by conditioning on the confounding effects of <span class="math inline">\(L\)</span>:</p>
<p>$$</p>
<p>ATE_{} = [Y(|L) - Y(|L)]</p>
<p>$$</p>
<p>When asking causal questions about the economic effect of adopting Protestantism versus remaining Catholic, several challenges arise regarding the three fundamental assumptions required for causal inference.</p>
<p><strong>Causal Consistency</strong>: This requires that the outcome under each level of treatment to be compared is well-defined. In this context, defining what ‘adopting Protestantism’ and ‘remaining Catholic’ mean may present challenges. The practices and beliefs of each religion might vary significantly across countries and time periods, making it difficult to create a consistent, well-defined treatment. Furthermore, the outcome—economic development—may also be challenging to measure consistently across different countries and time periods.</p>
<p>There is undoubtedly considerable heterogeneity in the ‘Protestant treatment.’ In England, Protestantism was closely tied to the monarchy <span class="citation" data-cites="collinson2003">[@collinson2003]</span>. In Germany, Martin Luther’s teachings emphasised individual faith in scripture, which, it has been claimed, supported economic development by promoting literacy <span class="citation" data-cites="gawthrop1984">[@gawthrop1984]</span>. In England, King Henry VIII abolished Catholicism <span class="citation" data-cites="collinson2003">[@collinson2003]</span>. The Reformation, then, occurred differently in different places. The treatment needs to be better defined.</p>
<p>There is also ample scope for interference: 16th-century societies were interconnected through trade, diplomacy, and warfare. Thus, the religious decisions of one society were unlikely to have been independent from those of other societies.</p>
<p><strong>Exchangeability</strong>: This requires that given the confounders, the potential outcomes are independent of the treatment assignment. It might be difficult to account for all possible confounders in this context. For example, historical, political, social, and geographical factors could influence both a country’s religious affiliations and its economic development.</p>
<p><strong>Positivity</strong>: This requires that there is a non-zero probability of every level of treatment for every stratum of confounders. If we consider various confounding factors such as geographical location, historical events, or political circumstances, some countries might only ever have the possibility of either remaining Catholic or becoming Protestant, but not both. For example, it is unclear under which conditions 16th-century Spain could have been randomly assigned to Protestantism <span class="citation" data-cites="nalle1987 westreich2010">[@nalle1987; @westreich2010]</span>.</p>
<p>Perhaps a more credible measure of effect in the region of our interests is the Average Treatment Effect in the Treated (ATT) expressed:</p>
<p>$$</p>
<p>ATT_{} = [(Y(a^<em>) - Y(a))|A = a^</em>,L]</p>
<p>$$</p>
<p>Where <span class="math inline">\(Y(a^*)\)</span> represents the potential outcome if treated, and <span class="math inline">\(Y(a)\)</span> represents the potential outcome if not treated. The expectation is taken over the distribution of the treated units (i.e., those for whom <span class="math inline">\(A = a^*\)</span>). <span class="math inline">\(L\)</span> is a set of covariates on which we condition to ensure that the potential outcomes <span class="math inline">\(Y(a^*)\)</span> and <span class="math inline">\(Y(a)\)</span> are independent of the treatment assignment <span class="math inline">\(A\)</span>, given <span class="math inline">\(L\)</span>. This accounts for any confounding factors that might bias the estimate of the treatment effect.</p>
<p>Here, the ATT defines the expected difference in economic success for cultures that became Protestant compared with the expected economic success if those cultures had not become Protestant, conditional on measured confounders <span class="math inline">\(L\)</span>, among the exposed (<span class="math inline">\(A = a^*\)</span>). To estimate this contrast, our models would need to match Protestant cultures with comparable Catholic cultures effectively. By estimating the ATT, we avoid the assumption of non-deterministic positivity for the untreated. However, whether matching is conceptually plausible remains debatable. Ostensibly, it would seem that assigning a religion to a culture is not as easy as administering a pill <span class="citation" data-cites="watts2018">[@watts2018]</span>.</p>
<div style="page-break-after: always;"></div>
</section>
<section id="id-app-c" class="level2">
<h2 class="anchored" data-anchor-id="id-app-c">S3. Causal Consistency Under Multiple Versions of Treatment</h2>
<p>To better understand how the causal consistency assumption might fail, consider a question discussed in the evolutionary human science literature about whether a society’s beliefs in big Gods affect its development of social complexity <span class="citation" data-cites="whitehouse2023 slingerland2020coding beheim2021 watts2015 sheehan2022 johnson2015 norenzayan2016">[@whitehouse2023; @slingerland2020coding; @beheim2021; @watts2015; @sheehan2022; @johnson2015; @norenzayan2016]</span>. Historians and anthropologists report that such beliefs vary over time and across cultures in intensity, interpretations, institutional management, and rituals <span class="citation" data-cites="decoulanges1903 wheatley1971 bulbuliaj.2013 geertz2013">[@decoulanges1903; @wheatley1971; @bulbuliaj.2013; @geertz2013]</span>. This variation in content and settings could influence social complexity. Moreover, the treatments realised in one society might affect those realised in other societies, resulting in <em>spill-over</em> effects in the exposures (‘treatments’) to be compared <span class="citation" data-cites="murray2021a shiba2023uncovering">[@murray2021a; @shiba2023uncovering]</span>.</p>
<p>The theory of causal inference under multiple versions of treatment, developed by VanderWeele and Hernán, formally addresses this challenge of treatment-effect heterogeneity <span class="citation" data-cites="vanderweele2009 vanderweele2013 vanderweele2018">[@vanderweele2009; @vanderweele2013; @vanderweele2018]</span>. The authors proved that if the treatment variations, <span class="math inline">\(K\)</span>, are conditionally independent of the potential outcomes, <span class="math inline">\(Y(k)\)</span>, given covariates <span class="math inline">\(L\)</span>, then conditioning on <span class="math inline">\(L\)</span> allows us to consistently estimate causal effects over the heterogeneous treatments <span class="citation" data-cites="vanderweele2009">[@vanderweele2009]</span>.</p>
<p>Where <span class="math inline">\(\coprod\)</span> denotes independence, we may assume causal consistency where the interventions to be compared are independent of their potential outcomes, conditional on covariates, <span class="math inline">\(L\)</span>:</p>
<p>$$</p>
<p>K Y(k) | L</p>
<p>$$</p>
<p>According to the theory of causal inference under multiple versions of treatment, we may think of <span class="math inline">\(K\)</span> as a ‘coarsened indicator’ for <span class="math inline">\(A\)</span>. Although the theory of causal inference under multiple versions of treatment provides a formal solution to the problems of treatment-effect heterogeneity and treatment-effect dependencies (also known as SUTVA—the ‘stable unit treatment value assumption’; refer to <span class="citation" data-cites="rubin1980randomization">@rubin1980randomization</span>), computing and interpreting causal effect estimates under this theory can be challenging.</p>
<p>Consider the question of whether a reduction in Body Mass Index (BMI) affects health <span class="citation" data-cites="hernán2008">[@hernán2008]</span>. Weight loss can occur through various methods, each with different health implications. Specific methods, such as regular exercise or a calorie-reduced diet, benefit health. However, weight loss might result from adverse conditions such as infectious diseases, cancers, depression, famine, or accidental amputations, which are generally not beneficial to health. Hence, even if causal effects of ‘weight loss’ could be consistently estimated when adjusting for covariates <span class="math inline">\(L\)</span>, we might be uncertain about how to interpret the effect we are consistently estimating. This uncertainty highlights the need for precise and well-defined causal questions. For example, rather than stating the intervention vaguely as ‘weight loss’, we could state the intervention clearly and specifically as ‘weight loss achieved through aerobic exercise over at least five years, compared with no weight loss.’ This specificity in the definition of the treatment, along with comparable specificity in the statement of the outcomes, helps ensure that the causal estimates we obtain are not merely unbiased but also interpretable; for discussion, see <span class="citation" data-cites="hernán2022">@hernán2022</span>; <span class="citation" data-cites="murray2021a">@murray2021a</span>; <span class="citation" data-cites="hernán2008">@hernán2008</span>.</p>
<p>Beyond uncertainties for the interpretation of heterogeneous treatment effect estimates, there is the additional consideration that we cannot fully verify from data whether the measured covariates <span class="math inline">\(L\)</span> suffice to render the multiple versions of treatment independent of the counterfactual outcomes. This problem is acute when there is <em>interference</em>, which occurs when treatment effects are relative to the density and distribution of treatment effects in a population. Scope for interference will often make it difficult to warrant the assumption that the potential outcomes are independent of the many versions of treatment that have been realised, dependently, on the administration of previous versions of treatments across the population <span class="citation" data-cites="bulbulia2023a ogburn2022 vanderweele2013">[@bulbulia2023a; @ogburn2022; @vanderweele2013]</span>.</p>
<p>In short, although the theory of causal inference under multiple versions of treatment provides a formal solution for consistent causal effect estimation in observational settings, <em>treatment heterogeneity</em> remains a practical threat. Generally, we should assume that causal consistency is unrealistic unless proven innocent.</p>
<p>For now, we note that the causal consistency assumption provides a theoretical starting point for recovering the missing counterfactuals required for computing causal contrasts. It identifies half of these missing counterfactuals directly from observed data. The concept of conditional exchangeability, which we examine next, offers a means for recovering the remaining half.</p>
<!-- 

Below is @díaz2021's formulation of @pearl2009a's mathematical representation of a structural causal model. I use @díaz2021's formulation because it allows us to present a structural causal model for dynamic treatment strategies @richardson2013, also known as longitudinal modified treatment policies @hoffman2023.





We begin by defining the sequence of variables in our model:



$$

S_i= (W, Y_0, L_1, A_1, L_2, A_2, ..., L_\tau, A_\tau, Y_{\tau}) \sim \mathbf{P}

$$

  

where $S_i$ is a sample from the distribution $\mathbf{P}$ and includes baseline covariates $W$, intermediate outcomes $L_t$, treatments $A_t$, and final outcomes $Y_{\tau}$ over time periods $t = 1, 2, \ldots, \tau$.



We define the final outcome:



$$

Y = A_{\tau + 1}

$$





We define the history of all variables up to treatment $A_t$ as:

   

$$

H_t = (\bar{A}_{t-1}, \bar{L}_t)

$$



Here, $\bar{A}_{t-1}$ represents the history of treatments up to time $t-1$, and $\bar{L}_t$ represents the history of intermediate outcomes up to time $t$.





We define the vector of exogenous variables (error terms). Note on Pearl's structural causal model account, but not the potential outcomes framework, the error terms must always be independent:



$$

U = (U_{L,t}, U_{A,t}, U_{Y}: t \in \{1 \dots \tau\})

$$



Where $U$ describes the set of exogenous variables affecting $L_t$, $A_t$, and $Y$.





We assume the following deterministic functions for the intermediate outcomes, treatments, and final outcome:

   

1. For intermediate outcomes:



$$

L_t = f_{L_t}(A_{t-1}, H_{t-1}, U_{L,t})

$$



2. For treatments:

   

$$

A_t = f_{A_t}(H_t, U_{A,t})

$$



3. For the final outcome:



$$

Y = f_{Y}(A_{\tau}, H_{\tau}, U_{Y})

$$





Longitudinal modified treatment policies (LMTPs) are defined as functions that assign treatments flexibly based on individual co-variate histories. Note that where there are multiple treatments, these histories will be partially counterfactual. 

   

We replace the deterministic function for treatments:



$$

A_t = f_{A_t}(H_t, U_{A,t})

$$



With the intervention function:



$$

A^\mathbf{g}_t

$$





On the structural causal model account, this intervention produces counterfactual histories given:



$$

L_t(\bar{A}^\mathbf{g}_{t-1}) = f_{L_t}(A^\mathbf{g}_{t-1}, H_{t-1}(\bar{A}^\mathbf{g}_{t-2}), U_{L,t})

$$





For treatments, the counterfactual variable $A_t(\bar{A}^\mathbf{g}_{t-1})$ is defined as the natural value of the treatment, i.e., the value of the treatment that would have been observed at time $t$ under the intervention history leading up to it at $t-1$, and then discontinued:



$$

A_t(\bar{A}^\mathbf{g}_{t-1}) = f_{A_t}(H_t(\bar{A}^\mathbf{g}_{t-1}), H_{t-1}(\bar{A}^\mathbf{g}_{t-2}), U_{L,t})

$$



When all variables are intervened on, the counterfactual final outcome is:



$$

Y(\bar{A}^\mathbf{g}) = f_Y(A^\mathbf{g}_\tau, H_\tau(\bar{A}^\mathbf{g}_{\tau-1}), U_{Y})

$$

 -->
<div style="page-break-after: always;"></div>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div id="refs" role="list">

</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>